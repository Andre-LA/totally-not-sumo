-- Copyright (c) 2022, AndrÃ© Luiz Alvares and Leonardo Santos
-- SPDX-License-Identifier: CC-BY-NC-SA-4.0

-- Disable GC and use 32-bit numbers by default
## context.rootpragmas.nogc = true
## primtypes.uinteger = primtypes.uint32
## primtypes.integer = primtypes.int32
## primtypes.number = primtypes.float32

-- require Gamecade global API
local gamercade = require 'gamercade'
local string = require 'string'
local math = require 'math'

-- utility to track the size of each record
##[[
local function log_size(attr)
  print(tostring(attr.value)..' size: '..attr.value.size..' bytes')
end
]]

local function rect(colors: uint16, x: int32, y: int32, w: int32, h: int32)
  local fill_color, outline_color = colors & 0x000f, colors & 0x00f0

  if fill_color ~= 0 then
    gamercade.rect_filled(gamercade.color_index(fill_color - 1), x + 80, y + 10, w, h)
  end

  if outline_color ~= 0 then
    gamercade.rect(gamercade.color_index((outline_color >> 4) - 1), x + 80, y + 10, w, h)
  end
end

local function draw_digit(digit: int32, x: int32, y: int32)
  local gp = gamercade.graphics_parameters(0, 2, digit)
  gamercade.sprite(gp, (1 << 63), x + 80, y + 10)
end

local function draw_integer_text(number: float32, x: int32, y: int32)
  local digits_len = math.floor(math.log(number, 10)) + 1
  x = math.ifloor(x + (digits_len - 1) * 9)

  for i = 0, < digits_len do
    local digit = math.ifloor(number % 10)
    draw_digit(digit, x - i*9, y)
    number = number / 10
  end
end

local function draw_winner_player_text(winner: byte, x: int32, y: int32)
  local gp = gamercade.graphics_parameters(0, 1, winner)
  gamercade.sprite(gp, (1<<63), x + 80, y + 10)
end

-- general types and methods --
local Vec2 = @record{
  x: int16, y: int16,
}
## log_size(Vec2)

function Vec2.__add(a: Vec2, b: Vec2): Vec2
  return Vec2{a.x + b.x, a.y + b.y}
end

function Vec2.__sub(a: Vec2, b: Vec2): Vec2
  return Vec2{a.x - b.x, a.y - b.y}
end

local Hitbox = @record{
  x: int16, y: int16, w: byte, h: byte
}
## log_size(Hitbox)

function Hitbox.get_center(self: Hitbox): Vec2
  return Vec2{
    x = math.ifloor(self.x + self.w/2),
    y = math.ifloor(self.y + self.h/2),
  }
end

function Hitbox:with_offset(pos: Vec2): Hitbox
  return Hitbox{self.x + pos.x, self.y + pos.y, self.w, self.h}
end

function Hitbox:is_point_intersecting(pt: *Vec2): boolean
  return (
    pt.x >= self.x and pt.x <= self.x + self.w and
    pt.y >= self.y and pt.y <= self.y + self.h
  )
end

function Hitbox:get_intersection(other: *Hitbox): (boolean, Hitbox)
  local no_intersection = (
    self.x + self.w < other.x or
    self.x > other.x + other.w or
    self.y > other.y + other.h or
    self.y + self.h < other.y
  )

  if likely(no_intersection) then
    return false, Hitbox{}
  else
    local p1x = math.max(self.x, other.x)
    local p1y = math.max(self.y, other.y)

    local p2x = math.min(self.x + self.w, other.x + other.w)
    local p2y = math.min(self.y + self.h, other.y + other.h)

    local w, h = math.abs(p2x - p1x), math.abs(p2y - p1y)

    local intersection: Hitbox = { p1x, p1y, w, h }
    return true, intersection
  end
end

function Hitbox:get_intersection_with_offsets(self_pos: *Vec2, other: *Hitbox, other_pos: *Vec2): (boolean, Hitbox)
  local self_hb, other_hb = self:with_offset(self_pos), other:with_offset(other_pos)
  return self_hb:get_intersection(other_hb)
end

function Hitbox:simple_collision(entity_hb_o: Hitbox, entity_pos: *Vec2): boolean
  local entity_hb = entity_hb_o:with_offset(entity_pos)
  local is_intersecting, intersection = self:get_intersection(entity_hb)

  if is_intersecting then
    local self_center, entity_center = self:get_center(), entity_hb:get_center()

    if intersection.w > intersection.h then
      if self_center.y > entity_center.y then
        entity_pos.y = self.y - entity_hb.h - entity_hb_o.y
      else
        entity_pos.y = self.y + self.h - entity_hb_o.y
      end
    elseif intersection.w < intersection.h then
      if self_center.x > entity_center.x then
        entity_pos.x = self.x - entity_hb.w - entity_hb_o.x
      else
        entity_pos.x = self.x + self.w - entity_hb_o.x
      end
    else
      if self_center.y > entity_center.y then
        entity_pos.y = self.y - entity_hb.h - entity_hb_o.y
      else
        entity_pos.y = self.y + self.h - entity_hb_o.y
      end
      if self_center.x > entity_center.x then
        entity_pos.x = self.x - entity_hb.w - entity_hb_o.x
      else
        entity_pos.x = self.x + self.w - entity_hb_o.x
      end
    end
  end

  return is_intersecting
end

local function draw_hitbox(hb: *Hitbox, colors: uint16)
  rect(colors, hb.x, hb.y, hb.w, hb.h)
end

local function draw_sprite(frame: Vec2, pos: Vec2, palette_index: int32, flip_x: facultative(boolean))
  ## if flip_x.type.is_niltype then
  local flip_x = 0
  ## else
  local flip_x = flip_x and 1 or 0
  ## end -- local frame: Vec2 = { (16 * 3), (20 * 9) }

  local frame_index = frame.x + (frame.y*6)
  local gp = gamercade.graphics_parameters(palette_index, 0, frame_index, 0, flip_x)

  gamercade.sprite(gp, (1 << 63), pos.x + 80, pos.y + 10)
end

-- entities --

local CharacterState = @enum(byte){
  Idle = 0, Walking, Attacking
}

local Character = @record{
  hb_receiver: Hitbox,
  hb_attacker: Hitbox,
  hb_ground: Hitbox,
  pos: Vec2,
  frame: Vec2,
  frames_on_state: int32,
  state: CharacterState,
  flip: record{ x: boolean },
  health_pts: int8,
  controller: byte,
}
## log_size(Character)

function Character.hb_attacker_right(): Hitbox
  return Hitbox{16, 4, 15, 11}
end

function Character.hb_attacker_left(): Hitbox
  return Hitbox{-15, 4, 15, 11}
end

function Character.hb_attacker_up(): Hitbox
  return Hitbox{-1, -6, 11, 15}
end

function Character.hb_attacker_down(): Hitbox
  return Hitbox{6, 12, 11, 15}
end


function Character.init(x: int16, y: int16, controller: byte): Character
  return Character{
    pos = { =x, =y },
    hb_receiver = { 2, 4, 12, 12},
    hb_ground = { 4, 12, 8, 8},
    hb_attacker = controller == 0 and Character.hb_attacker_right() or Character.hb_attacker_left(),
    flip = { x = controller == 1 },
    =controller,
  }
end

function Character:attacked_by(attacker: *Character)
  local self_hb_center = self.hb_receiver:with_offset(self.pos):get_center()
  local attacker_hb_center = attacker.hb_receiver:with_offset(attacker.pos):get_center()
  local diff = self_hb_center - attacker_hb_center

  if math.abs(diff.x) > math.abs(diff.y) then
    self.pos.x = self.pos.x + 8 * math.sign(diff.x)
  else
    self.pos.y = self.pos.y + 8 * math.sign(diff.y)
  end
end

-- game state --

local arena_border <comptime> = 1

local GameState = @record{
  arena: Hitbox,
  frame_counter: uint32,
  points: [2]byte,
  winner_player: byte,
  on_transition: boolean,
  transition_frame: uint32,
  characters: [4]Character,
  walls: [11]Hitbox,
}
## log_size(GameState)

function GameState:player_wins(idx: byte)
  self.points[idx] = self.points[idx] + 1
  self.on_transition = true
  self.transition_frame = self.frame_counter
  self.winner_player = idx
end

function GameState:player_try_hit(attacker: *Character)
  for i = 0, < #self.characters do
    if (attacker.hb_attacker:get_intersection_with_offsets(attacker.pos, self.characters[i].hb_receiver, self.characters[i].pos)) then
      self.characters[i]:attacked_by(attacker)
      break
    end
  end
end

function GameState:check_out(idx: byte): boolean
  local c_hb = self.characters[idx].hb_ground:with_offset(self.characters[idx].pos)
  return not (self.arena:get_intersection(c_hb))
end

function GameState:reset_level()
  local points = self.points

  $self = {
    arena = { 16 + arena_border, 16 + arena_border, (160 - 16*2 - arena_border*2), (160 - 16*2 - arena_border*2) },
    =points,
    characters = {
      Character.init( 32,  32, 0),
      Character.init( 32, 104, 0),
      Character.init(112,  32, 1),
      Character.init(112, 104, 1)
    },
    walls = {
      Hitbox{  16,  16, 32,  8 },
      Hitbox{  16,  24, 8,  16 },

      Hitbox{  48,  16,  8, 64 },

      Hitbox{  76,  80-32-8,  8,  8 },
      Hitbox{  76,  80-4 ,  8,  8 },
      Hitbox{  76,  80+32,  8,  8 },

      Hitbox{  48,  80+16,  8,  8 },
      Hitbox{  104, 80-16-8,  8,  8 },

      Hitbox{ 112, 136, 32,  8 },
      Hitbox{ 136, 120, 8,  16 },

      Hitbox{ 104,  80,  8, 64 },
    },
  }
end

global game: GameState
game:reset_level()

-- game logic --

function Character:set_state(state: CharacterState)
  self.frames_on_state = 0
  self.state = state
end

function Character:update(idx: byte)
  self.frames_on_state = self.frames_on_state + 1

  local ms_per_frame <comptime> = 120

  if game.frame_counter % (60//(1000/ms_per_frame)) == 0 then
    self.frame.x = (self.frame.x + 1) % 6
  end

  if self.state == CharacterState.Attacking and self.frame.x == 3 then
    self:set_state(CharacterState.Idle)
    self.frame.x = 0

    switch self.frame.y do
      case 2, 3, 7 then self.frame.y = 2
      case 4, 5, 8 then self.frame.y = 4
      else self.frame.y = 0
    end
  end

  check(self.controller == 0 or self.controller == 1, 'invalid controller')

  if self.state ~= CharacterState.Attacking then
    if gamercade.button_right_held(self.controller) |
       gamercade.button_left_held(self.controller)  |
       gamercade.button_up_held(self.controller)    |
       gamercade.button_down_held(self.controller)  |
       gamercade.button_a_held(self.controller) == 0
    then
      self:set_state(CharacterState.Idle)

      switch self.frame.y do
        case 2, 3, 7 then self.frame.y = 2
        case 4, 5, 8 then self.frame.y = 4
        else self.frame.y = 0
      end

    elseif gamercade.button_a_held(self.controller) > 0 then
      self:set_state(CharacterState.Attacking)
      game:player_try_hit(self)
      self.frame.x = 0

      switch self.frame.y do
        case 0, 1 then self.frame.y = 6
        case 2, 3 then self.frame.y = 7
        case 4, 5 then self.frame.y = 8
        else self.frame.y = 6
      end

    else
      self:set_state(CharacterState.Walking)

      local can_move = true

      if idx % 2 == 0 then
        local hb = self.hb_receiver
        hb.x, hb.y, hb.w, hb.h = hb.x - 4, hb.y - 4, hb.w + 8, hb.h + 8
        local is_out = game:check_out(idx+1)
        local is_near = (hb:get_intersection_with_offsets(self.pos, game.characters[idx+1].hb_receiver, game.characters[idx+1].pos))
        can_move = is_out and true or not is_near
      end

      if can_move then
        if gamercade.button_right_held(self.controller) > 0 then
          self.pos.x = self.pos.x + 1
          self.hb_attacker = Character.hb_attacker_right()
          self.frame.y = 1
          self.flip.x = false
        end
        if gamercade.button_left_held(self.controller) > 0 then
          self.pos.x = self.pos.x - 1
          self.hb_attacker = Character.hb_attacker_left()
          self.frame.y = 1
          self.flip.x = true
        end
        if gamercade.button_up_held(self.controller) > 0 then
          self.pos.y = self.pos.y - 1
          self.hb_attacker = Character.hb_attacker_up()
          self.frame.y = 5
          self.flip.x = false
        end
        if gamercade.button_down_held(self.controller) > 0 then
          self.pos.y = self.pos.y + 1
          self.hb_attacker = Character.hb_attacker_down()
          self.frame.y = 3
          self.flip.x = false
        end
      end
    end
  end
end

function Character:draw(idx: byte)
  local function draw_attack(self: *Character)
    local frame_y, offset_x, offset_y = self.frame.y, 0, 0

    switch frame_y do
      case 0, 1, 6 then frame_y = 9 offset_y = -6
      case 2, 3, 7 then frame_y = 10 offset_x = -3 offset_y = -2
      case 4, 5, 8 then frame_y = 11 offset_x = -3
    end

    if frame_y == 9 then
      if self.flip.x then
        offset_x = 0
      end
    end

    local pos: Vec2 = self.pos + Vec2{ self.hb_attacker.x, self.hb_attacker.y } + Vec2{ offset_x, offset_y }
    local frame: Vec2 = { self.frame.x, frame_y }

    draw_sprite(frame, pos, self.controller, self.flip.x)
  end

  if game:check_out(idx) then
    draw_sprite({ 3, 9 }, self.pos, self.controller)
  else
    local attack_is_up = self.frame.y == 4 or self.frame.y == 5 or self.frame.y == 8

    if attack_is_up and self.state == CharacterState.Attacking then
      draw_attack(self)
    end

    draw_sprite(self.frame, self.pos, self.controller, self.flip.x)

    if not attack_is_up and self.state == CharacterState.Attacking then
      draw_attack(self)
    end
  end
end

-- game loop --

function GameState:update()
  -- update --
  self.frame_counter = self.frame_counter + 1

  if not self.on_transition then
    for i = 0, < #self.characters do
      if not self:check_out(i) then
        self.characters[i]:update(i)
      end
    end

    if self:check_out(0) and self:check_out(1) then
      game:player_wins(1)
    elseif self:check_out(2) and self:check_out(3) then
      game:player_wins(0)
    end
  elseif self.frame_counter - self.transition_frame > 120 then
    game:reset_level()
  end
end

function GameState:draw()
  gamercade.clear_screen(gamercade.color_index(2))

  local colors: uint16 = 0x0003
  rect(colors, 0, 0, 160, 160)

  local colors: uint16 = 0x0022
  rect(
    colors,
    game.arena.x - arena_border,
    game.arena.y - arena_border,
    game.arena.w + (arena_border*2),
    game.arena.h + (arena_border*2)
  )

  local colors: uint16 = 0x0030
  rect(
    colors,
    game.arena.x,
    game.arena.y,
    game.arena.w,
    game.arena.h
  )

  for i = 0, < #self.walls do
    draw_hitbox(self.walls[i], 0x0011)
  end

  for i = 0, < #self.walls do
    for j = 0, < #self.characters do
      self.walls[i]:simple_collision(self.characters[j].hb_ground, self.characters[j].pos)
    end
  end

  for i = 0, < #self.characters do
    self.characters[i]:draw(i)
  end

  do
    draw_integer_text(game.points[0], 2, 2)
    draw_integer_text(game.points[1], 160-18, 2)

    if self.on_transition then
      local fdiff = self.frame_counter - self.transition_frame

      local colors: uint16 = 0x0003
      local rw <comptime> = (160-24*2)
      rect(colors, 24, 68, math.min(math.ifloor((fdiff / 120) * 4 * rw), rw), 16)

      draw_winner_player_text(self.winner_player, 28, 72)
    end
  end
end

local function update()
  game:update()
end

local function draw()
  game:draw()
end

## gamercade.value.setup_gamercade_callbacks(update, draw)

